<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-10-21T20:48:48+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">shchoi’s TIL</title><subtitle>Better than yesterday.</subtitle><author><name>Your Name</name></author><entry><title type="html">분산처리</title><link href="http://localhost:4000/%EB%B6%84%EC%82%B0%EC%B2%98%EB%A6%AC/" rel="alternate" type="text/html" title="분산처리" /><published>2021-10-21T00:00:00+09:00</published><updated>2021-10-21T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B6%84%EC%82%B0%EC%B2%98%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/%EB%B6%84%EC%82%B0%EC%B2%98%EB%A6%AC/">&lt;h3 id=&quot;분산-및-병렬처리의-필요성&quot;&gt;분산 및 병렬처리의 필요성&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;웹에 있는 모든 웹 서비스를 하나의 시스템에 집어넣는 집중화된 시스템을 갖는다면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;먼 거리에 있는 유저들이 접근할 때 네트워크 병목현상이 일어날 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동시 접속하는 과정에서 네트워크뿐만 아니라 서비스에 대한 요청이 잘 이뤄지지 않을 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-시스템을-설계할-때-고려사항&quot;&gt;분산 시스템을 설계할 때 고려사항&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Transparency: 투명성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scalability: 확장성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Concurrency: 동시성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failure Handling&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Transparency(투명성)&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 동작의 하부가 복잡하더라도 user입장에서는 single computer system으로 느껴지게 하는 것.&lt;/li&gt;
      &lt;li&gt;어떤 시스템을 통해 접근하더라도 똑같은 인터페이스를 제공해야한다.&lt;/li&gt;
      &lt;li&gt;투명성을 극대화시키면 관리를 위한 management에서 성능적인 overhead가 발생할 수 있다.&lt;/li&gt;
      &lt;li&gt;따라서 사용자에 따라 유리하게 투명성을 제공해야한다. 성능이 떨어질 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Scalability(확장성)&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;규모가 커지고 효율성이 증대되는 의미 그리고 반대로, user수가 떨어졌을때 규모를 축소하여 작은 규모로 효율적이게 사용할수 있도록 축소시키는 것도 확장성이라 말할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Concurrency(일관성)&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;동시에 접근할 때, 각 자원들의 상태가 동일해야한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Failure Handling&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;분산 시스템을 구성하는 일부 컴퓨터들이 고장난다 하더라도 그 시스템이 계속해서 사용자에게 일관성 있는 컴퓨팅 써비스를 제공할 수 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;출처:&lt;/p&gt;

&lt;p&gt;https://jihyeong-ji99hy99.tistory.com/102?category=889831&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">분산 및 병렬처리의 필요성</summary></entry><entry><title type="html">Message Queue</title><link href="http://localhost:4000/Message-Queue/" rel="alternate" type="text/html" title="Message Queue" /><published>2021-10-20T00:00:00+09:00</published><updated>2021-10-20T00:00:00+09:00</updated><id>http://localhost:4000/Message-Queue</id><content type="html" xml:base="http://localhost:4000/Message-Queue/">&lt;h1 id=&quot;mq란&quot;&gt;MQ란?&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;MQ (Message Queue) 란 메시지 기반의 미들웨어로 메시지를 이용하여 여러 어플리케이션, 시스템, 서비스들을 연결해주는 솔루션이다.&lt;/li&gt;
  &lt;li&gt;MOM(Message Oriented Middleware) 를 구현한 솔루션으로 비동기 메시지를 사용하는 서비스들 사이에서 데이터를 교환해주는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;Producer(sender) 가 메시지를 큐에 전송하면 Consumer(receiver) 가 처리하는 방식으로, producer 와 consumer 에 message 프로세스가 추가되는 것이 특징이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;메시지를 발행하는 사용자와 이를 소비하는 사용자 간의
강한 결합으로 인하여 발생하는,
깨지기 쉬운 성질 등을 가지는 동기식 방식은
마이크로서비스가 가지는 ‘느슨한 결합’ 이라는 특성과 어울리지 않다.
메시지를 발행하는 클라이언트가 이용하는 서비스를 &lt;strong&gt;&lt;em&gt;[조직 서비스]&lt;/em&gt;&lt;/strong&gt;,
메시지를 소비하는 클라이언트가 이용하는 서비스를 &lt;strong&gt;&lt;em&gt;[라이선싱 서비스]&lt;/em&gt;&lt;/strong&gt;라고 가정해보겠다.
메시지 큐 방식을 사용하면 라이선싱 및 조직 서비스 사이에 큐를 삽입한다. 
이 큐는 &lt;strong&gt;&lt;em&gt;[조직 서비스]&lt;/em&gt;&lt;/strong&gt;의 데이터를 읽는 데 사용되는 것이 아니라, &lt;strong&gt;&lt;em&gt;[조직 서비스]&lt;/em&gt;&lt;/strong&gt;가 관리하는 조직 데이터의 상태가 변할 때 &lt;strong&gt;&lt;em&gt;[조직 서비스]&lt;/em&gt;&lt;/strong&gt;가 메시지를 발행하는데 사용이 된다.    
즉, 메시지 전달에서 메시지 큐는 라이선싱 서비스와 조직 서비스 사이의 중개자 역할을 하게 됨으로써
마이크로서비스의 특징인 &lt;strong&gt;&lt;em&gt;‘느슨한 결합’, ‘내구성’, ‘확장성’, ‘유연성’&lt;/em&gt;&lt;/strong&gt;을 제공하게 된다.&lt;/p&gt;

&lt;p&gt;출처:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://creakycogwheel.tistory.com/entry/%EC%BA%A1%EC%8A%A4%ED%86%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%9E%80&quot;&gt;https://creakycogwheel.tistory.com/entry/캡스톤-프로젝트메시지-큐란&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sarc.io/index.php/miscellaneous/1615-message-queue-mq&quot;&gt;https://sarc.io/index.php/miscellaneous/1615-message-queue-mq&lt;/a&gt;&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">MQ란?</summary></entry></feed>