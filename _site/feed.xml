<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-10-22T21:13:06+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">shchoi’s TIL</title><subtitle>Better than yesterday.</subtitle><author><name>Your Name</name></author><entry><title type="html">웹의 동작 방식</title><link href="http://localhost:4000/%EC%9B%B9%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/" rel="alternate" type="text/html" title="웹의 동작 방식" /><published>2021-10-22T00:00:00+09:00</published><updated>2021-10-22T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9B%B9%EC%9D%98%20%EB%8F%99%EC%9E%91%20%EB%B0%A9%EC%8B%9D</id><content type="html" xml:base="http://localhost:4000/%EC%9B%B9%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/">&lt;h1 id=&quot;웹의-동작-방식&quot;&gt;웹의 동작 방식&lt;/h1&gt;

&lt;p&gt;브라우저에 웹 주소를 입력하면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;브라우저는 DNS 서버로 가서 웹사이트가 있는 서버의 진짜 주소를 찾는다&lt;/li&gt;
  &lt;li&gt;그 다음 브라우저는 서버에게 웹사이트의 사본을 클라이언트에게 보내달라는 HTTP요청을 서버로 전송한다. 이 때, 클라이언트와 서버 사이에 전송되는 모든 데이터는 TCP/IP 연결을 통해 전송된다&lt;/li&gt;
  &lt;li&gt;요청을 받은 서버는 웹사이트의 파일들을 데이터 패킷이라 불리는 단위로 브라우저에게 전송한다.&lt;/li&gt;
  &lt;li&gt;브라우저는 이 데이터들을 완전한 웹 사이트로 조립하여 보여준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;dnsdomain-name-system-servers&quot;&gt;DNS(Domain Name System Servers)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;도메인 웹주소와 웹사이트의 실제 IP주소를 맞춰주는 서버&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;구성 요소 및 동작 원리&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;../img/dns.png&quot; alt=&quot;DNS 동작 방식&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DNS 동작과정&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Query (from Web Browser to Local DNS) : “제가 원하는 웹 사이트의 IP 주소를 알고 계신가요?” Local DNS 서버에게 전달&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Query (from Local DNS to Root DNS) : “제가 원하는 웹 사이트의 IP 주소를 알고 계신가요?” Root DNS서버에게 전달&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Response (from Root DNS to Local DNS) : “저는 모르지만 , Com 도메인을 관리하는 네임서버의 이름과 IP 주소를 알려드릴 테니 거기에 물어보세요”&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Query (from Local DNS to com NS) : “ 안녕하세요. www. naver. com의 IP 주소를 알고 계신가요?”&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Response (from com NS to Local DNS) : “저는 모르지만 , Com 도메인을 관리하는 네임서버의 이름과 IP 주소를 알려드릴 테니 거기에 물어보세요”&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Query (from Local DNS to naver. com NS) : “ 안녕하세요. www. Naver .com의 IP 주소를 알고 계신가요?”&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Response (from naver .com NS to Local DNS) : “저는 모르지만 해당 웹은 www. g.naver. com이라는 이름으로 통해요. g.naver .com 도메인을 관리하는 네임서버의 이름과 IP 주소를 알려드릴테니 거기에 물어보세요”&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Query (from Local DNS to g.naver. com NS) : “ 안녕하세요. www. g.naver. com의 IP 주소를 알고 계신가요?”&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Response (from g.naver .com NS to Local DNS) : “ 네 www. g.naver .com의 IP 주소는 222.222.222.22와 333.333.333.33입니다”&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DNS Response (from Local DNS to Web Browser) : “네 www. naver .com의 IP 주소는 222.222.222.22와 333.333.333.33입니다”&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;패킷&quot;&gt;패킷&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;데이터가 웹을 거쳐서 전송될 때, 수천 개의 작은 덩어리로 전송된다. 만약 하나의 큰 덩어리로 전송된다면, 한 번에 하나의 사용자만 다운로드 할 수 있을 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참조:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/How_the_Web_works&quot;&gt;https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/How_the_Web_works&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ja-gamma.tistory.com/entry/DNS%EA%B0%9C%EB%85%90%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC&quot;&gt;https://ja-gamma.tistory.com/entry/DNS%EA%B0%9C%EB%85%90%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC&lt;/a&gt;&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">웹의 동작 방식</summary></entry><entry><title type="html">분산처리</title><link href="http://localhost:4000/%EB%B6%84%EC%82%B0%EC%B2%98%EB%A6%AC/" rel="alternate" type="text/html" title="분산처리" /><published>2021-10-21T00:00:00+09:00</published><updated>2021-10-21T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B6%84%EC%82%B0%EC%B2%98%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/%EB%B6%84%EC%82%B0%EC%B2%98%EB%A6%AC/">&lt;h3 id=&quot;분산-및-병렬처리의-필요성&quot;&gt;분산 및 병렬처리의 필요성&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;웹에 있는 모든 웹 서비스를 하나의 시스템에 집어넣는 집중화된 시스템을 갖는다면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;먼 거리에 있는 유저들이 접근할 때 네트워크 병목현상이 일어날 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동시 접속하는 과정에서 네트워크뿐만 아니라 서비스에 대한 요청이 잘 이뤄지지 않을 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-시스템을-설계할-때-고려사항&quot;&gt;분산 시스템을 설계할 때 고려사항&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Transparency: 투명성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scalability: 확장성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Concurrency: 동시성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failure Handling&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Transparency(투명성)&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 동작의 하부가 복잡하더라도 user입장에서는 single computer system으로 느껴지게 하는 것.&lt;/li&gt;
      &lt;li&gt;어떤 시스템을 통해 접근하더라도 똑같은 인터페이스를 제공해야한다.&lt;/li&gt;
      &lt;li&gt;투명성을 극대화시키면 관리를 위한 management에서 성능적인 overhead가 발생할 수 있다.&lt;/li&gt;
      &lt;li&gt;따라서 사용자에 따라 유리하게 투명성을 제공해야한다. 성능이 떨어질 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Scalability(확장성)&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;규모가 커지고 효율성이 증대되는 의미 그리고 반대로, user수가 떨어졌을때 규모를 축소하여 작은 규모로 효율적이게 사용할수 있도록 축소시키는 것도 확장성이라 말할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Concurrency(일관성)&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;동시에 접근할 때, 각 자원들의 상태가 동일해야한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Failure Handling&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;분산 시스템을 구성하는 일부 컴퓨터들이 고장난다 하더라도 그 시스템이 계속해서 사용자에게 일관성 있는 컴퓨팅 써비스를 제공할 수 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;출처:&lt;/p&gt;

&lt;p&gt;https://jihyeong-ji99hy99.tistory.com/102?category=889831&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">분산 및 병렬처리의 필요성</summary></entry><entry><title type="html">Message Queue</title><link href="http://localhost:4000/Message-Queue/" rel="alternate" type="text/html" title="Message Queue" /><published>2021-10-20T00:00:00+09:00</published><updated>2021-10-20T00:00:00+09:00</updated><id>http://localhost:4000/Message-Queue</id><content type="html" xml:base="http://localhost:4000/Message-Queue/">&lt;h1 id=&quot;mq란&quot;&gt;MQ란?&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;MQ (Message Queue) 란 메시지 기반의 미들웨어로 메시지를 이용하여 여러 어플리케이션, 시스템, 서비스들을 연결해주는 솔루션이다.&lt;/li&gt;
  &lt;li&gt;MOM(Message Oriented Middleware) 를 구현한 솔루션으로 비동기 메시지를 사용하는 서비스들 사이에서 데이터를 교환해주는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;Producer(sender) 가 메시지를 큐에 전송하면 Consumer(receiver) 가 처리하는 방식으로, producer 와 consumer 에 message 프로세스가 추가되는 것이 특징이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;메시지를 발행하는 사용자와 이를 소비하는 사용자 간의
강한 결합으로 인하여 발생하는,
깨지기 쉬운 성질 등을 가지는 동기식 방식은
마이크로서비스가 가지는 ‘느슨한 결합’ 이라는 특성과 어울리지 않다.
메시지를 발행하는 클라이언트가 이용하는 서비스를 &lt;strong&gt;&lt;em&gt;[조직 서비스]&lt;/em&gt;&lt;/strong&gt;,
메시지를 소비하는 클라이언트가 이용하는 서비스를 &lt;strong&gt;&lt;em&gt;[라이선싱 서비스]&lt;/em&gt;&lt;/strong&gt;라고 가정해보겠다.
메시지 큐 방식을 사용하면 라이선싱 및 조직 서비스 사이에 큐를 삽입한다. 
이 큐는 &lt;strong&gt;&lt;em&gt;[조직 서비스]&lt;/em&gt;&lt;/strong&gt;의 데이터를 읽는 데 사용되는 것이 아니라, &lt;strong&gt;&lt;em&gt;[조직 서비스]&lt;/em&gt;&lt;/strong&gt;가 관리하는 조직 데이터의 상태가 변할 때 &lt;strong&gt;&lt;em&gt;[조직 서비스]&lt;/em&gt;&lt;/strong&gt;가 메시지를 발행하는데 사용이 된다.    
즉, 메시지 전달에서 메시지 큐는 라이선싱 서비스와 조직 서비스 사이의 중개자 역할을 하게 됨으로써
마이크로서비스의 특징인 &lt;strong&gt;&lt;em&gt;‘느슨한 결합’, ‘내구성’, ‘확장성’, ‘유연성’&lt;/em&gt;&lt;/strong&gt;을 제공하게 된다.&lt;/p&gt;

&lt;p&gt;출처:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://creakycogwheel.tistory.com/entry/%EC%BA%A1%EC%8A%A4%ED%86%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90%EB%9E%80&quot;&gt;https://creakycogwheel.tistory.com/entry/캡스톤-프로젝트메시지-큐란&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sarc.io/index.php/miscellaneous/1615-message-queue-mq&quot;&gt;https://sarc.io/index.php/miscellaneous/1615-message-queue-mq&lt;/a&gt;&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">MQ란?</summary></entry></feed>